<!doctype html><html lang=en><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# website: http://ogp.me/ns/website#"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content><meta property="og:title" content="No, you don't need Oh My Zsh"><meta property="og:type" content="article"><meta property="article:published_time" content="2025-06-23"><meta property="og:description" content><meta property="og:url" content="https://segflow.github.io/post/no-you-dont-need-ohmyzsh/"><meta property="og:site_name" content="Segflow"><meta property="og:tags" content="zsh"><meta property="og:tags" content="shell"><meta property="og:tags" content="terminal"><meta property="og:tags" content="productivity"><meta name=generator content="Hugo 0.147.2"><title>No, you don't need Oh My Zsh &#183; Segflow</title>
<link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://segflow.github.io/css/style.css><link rel=icon href=https://segflow.github.io/favicon.ico></head><body><nav class="navbar navbar-default navbar-fixed-top visible-xs"><div class=container-fluid><div class=navbar-header><button type=button class="navbar-toggle collapsed" data-toggle=collapse data-target=#bs-example-navbar-collapse-1>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=https://segflow.github.io/>Segflow</a></div><div class="collapse navbar-collapse" id=bs-example-navbar-collapse-1><ul class="nav navbar-nav"><li><a href=https://segflow.github.io//>Home</a></li><li><a href=https://segflow.github.io/post/>Posts</a></li><li><a href=https://segflow.github.io/resume.pdf>Resume</a></li></ul></div></div></nav><div class=container-fluid><div class=row><div id=menu class="hidden-xs col-sm-3 col-md-3"><div id=menu-content class=vertical-align><h1 class=text-center><a href=https://segflow.github.io/>Segflow</a></h1><small class="text-center center-block">Assel Meher</small>
<img id=profile-pic src=https://segflow.github.io//img/hacker_emblem.png alt="My Picture" class="img-circle center-block"><div id=social class=text-center><a href=https://github.com/segflow><i class="fa fa-github fa-2x"></i></a>
<a href=https://www.linkedin.com/in/meher-assel-0122798a><i class="fa fa-linkedin fa-2x"></i></a>
<a href=https://twitter.com/segfl0w><i class="fa fa-twitter fa-2x"></i></a>
<a href=mailto:asselmeher@gmail.com><i class="fa fa-envelope-o fa-2x"></i></a></div><div id=links class=text-center><a href=https://segflow.github.io//>Home</a>
<a href=https://segflow.github.io/post/>Posts</a>
<a href=https://segflow.github.io/resume.pdf>Resume</a></div></div></div><div id=content class="col-xs-12 col-sm-9 col-md-9"><div class=row><div id=post class="col-sm-offset-1 col-sm-10 col-md-10 col-lg-10"><main><header><h1>No, you don't need Oh My Zsh</h1></header><article><p>Don&rsquo;t get me wrong – Oh My Zsh is an excellent product. It&rsquo;s well-maintained, feature-rich, and has helped millions of developers enhance their shell experience. But here&rsquo;s the thing: <strong>you don&rsquo;t need it to have a great zsh experience</strong>.</p><p>When I recently set up a new workstation, I decided to skip Oh My Zsh entirely and configure zsh manually. The result? A lightweight, fast, and fully customized shell that does exactly what I need – nothing more, nothing less.</p><h2 id=the-oh-my-zsh-bloat-problem>The Oh My Zsh Bloat Problem</h2><p>Oh My Zsh comes with a lot of features out of the box. Themes, plugins, aliases, functions – it&rsquo;s a complete ecosystem. But here&rsquo;s the catch: most of us only use a tiny fraction of what it provides.</p><p>When you install Oh My Zsh, you get:</p><ul><li>Hundreds of themes (when you&rsquo;ll only use one)</li><li>Dozens of plugins (when you need maybe 3-4)</li><li>Tons of aliases (many of which you&rsquo;ll never remember)</li><li>Complex initialization scripts that slow down shell startup</li><li>A configuration system that abstracts away the underlying zsh mechanics</li></ul><p>This bloat has real consequences:</p><ul><li><strong>Slower shell startup</strong>: Every plugin and theme adds initialization time</li><li><strong>Complexity</strong>: It becomes harder to understand what&rsquo;s actually happening in your shell</li><li><strong>Dependencies</strong>: You become reliant on Oh My Zsh&rsquo;s structure and conventions</li></ul><h2 id=my-lightweight-alternative>My Lightweight Alternative</h2><p>Instead of Oh My Zsh, I built a minimal zsh configuration that focuses on the essentials. Here&rsquo;s what I actually need:</p><h3 id=1-smart-autosuggestions>1. Smart Autosuggestions</h3><p>The <code>zsh-autosuggestions</code> plugin suggests commands as you type based on your history:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Installation</span>
</span></span><span style=display:flex><span>git clone https://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions
</span></span></code></pre></div><h3 id=2-syntax-highlighting>2. Syntax Highlighting</h3><p>The <code>zsh-syntax-highlighting</code> plugin highlights commands as you type, showing invalid commands in red:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Installation</span>
</span></span><span style=display:flex><span>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ~/.zsh/zsh-syntax-highlighting
</span></span></code></pre></div><h3 id=3-enhanced-history-search>3. Enhanced History Search</h3><p>Instead of Oh My Zsh&rsquo;s history plugin, I use simple key bindings that let me search through history using arrow keys:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>bindkey <span style=color:#e6db74>&#39;\e[A&#39;</span> history-search-backward
</span></span><span style=display:flex><span>bindkey <span style=color:#e6db74>&#39;\e[B&#39;</span> history-search-forward
</span></span></code></pre></div><p>Now when I type <code>git </code>and press the up arrow, it only shows commands that start with <code>git</code> from my history. This is incredibly useful for finding that complex command you ran last week.</p><h3 id=4-tool-specific-autocompletion>4. Tool-Specific Autocompletion</h3><p>Instead of generic Oh My Zsh plugins, I load completions only for tools I actually use:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Docker completion</span>
</span></span><span style=display:flex><span>source &lt;<span style=color:#f92672>(</span>docker completion zsh<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># kubectl (with kubecolor if available)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> command -v kubecolor &gt;/dev/null 2&gt;&amp;1; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>  alias kubectl<span style=color:#f92672>=</span>kubecolor
</span></span><span style=display:flex><span>  compdef kubecolor<span style=color:#f92672>=</span>kubectl
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Google Cloud SDK</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -f <span style=color:#e6db74>&#39;/opt/homebrew/share/google-cloud-sdk/completion.zsh.inc&#39;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>  source <span style=color:#e6db74>&#39;/opt/homebrew/share/google-cloud-sdk/completion.zsh.inc&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span></code></pre></div><h2 id=smart-word-navigation>Smart Word Navigation</h2><p>One thing that frustrated me about default zsh was word jumping. When you press <code>Alt+→</code> to jump forward by word, it doesn&rsquo;t behave intuitively with paths or complex strings.</p><p>I fixed this with:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>autoload -Uz <span style=color:#66d9ef>select</span>-word-style
</span></span><span style=display:flex><span><span style=color:#66d9ef>select</span>-word-style normal
</span></span><span style=display:flex><span>zstyle <span style=color:#e6db74>&#39;:zle:*&#39;</span> word-style unspecified
</span></span></code></pre></div><p>Now when I have a path like <code>/usr/local/bin/my-script</code> and I&rsquo;m at the beginning:</p><ul><li><strong>Before</strong>: <code>Alt+→</code> jumps to the end of the entire path</li><li><strong>After</strong>: <code>Alt+→</code> jumps to each segment: <code>/usr</code> → <code>/local</code> → <code>/bin</code> → <code>/my</code> → <code>-script</code></li></ul><p>This makes editing long paths or URLs much more efficient.</p><h2 id=intelligent-completion-system>Intelligent Completion System</h2><p>Instead of Oh My Zsh&rsquo;s completion system, I configured zsh&rsquo;s built-in completion with smart behaviors:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Initialize completion system</span>
</span></span><span style=display:flex><span>autoload -Uz compinit
</span></span><span style=display:flex><span>compinit
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Smart case matching - lowercase matches both cases</span>
</span></span><span style=display:flex><span>zstyle <span style=color:#e6db74>&#39;:completion:*&#39;</span> matcher-list <span style=color:#e6db74>&#39;m:{a-z}={A-Z}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Menu selection for multiple matches</span>
</span></span><span style=display:flex><span>zstyle <span style=color:#e6db74>&#39;:completion:*&#39;</span> menu <span style=color:#66d9ef>select</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Error tolerance in completion</span>
</span></span><span style=display:flex><span>zstyle <span style=color:#e6db74>&#39;:completion:*&#39;</span> completer _complete _approximate
</span></span></code></pre></div><h3 id=menu-selection-in-action>Menu Selection in Action</h3><p>When I type <code>cd Pro</code> and hit tab, instead of just completing to the first match, I get a visual menu:</p><pre tabindex=0><code>cd Pro
&gt; Projects/     Programming/     Profile.txt
</code></pre><p>I can use arrow keys to select the right one. If I make a typo like <code>cd Porjects</code> and hit tab, zsh&rsquo;s approximate completion suggests:</p><pre tabindex=0><code>cd Porjects
correct to: Projects/ _
</code></pre><h2 id=starship-prompt-done-right>Starship: Prompt Done Right</h2><p>For my prompt, I chose <a href=https://starship.rs/>Starship</a> instead of Oh My Zsh themes. Starship is a single-purpose tool that does one thing exceptionally well: creating beautiful, informative prompts.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>eval <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>starship init zsh<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><p>Why Starship over Oh My Zsh themes?</p><ul><li><strong>Fast</strong>: Written in Rust, it&rsquo;s significantly faster than shell-based themes</li><li><strong>Cross-shell</strong>: Works with zsh, bash, fish, and more</li><li><strong>Single responsibility</strong>: Only handles prompts, doesn&rsquo;t mess with other shell functionality</li><li><strong>Highly configurable</strong>: Easy-to-understand TOML configuration</li><li><strong>No dependencies</strong>: Doesn&rsquo;t require Oh My Zsh or any other framework</li></ul><h2 id=essential-aliases-but-not-too-many>Essential Aliases (But Not Too Many)</h2><p>Oh My Zsh comes with hundreds of aliases. I keep mine minimal and memorable:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>alias ls<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;ls --color=auto&#39;</span>
</span></span><span style=display:flex><span>alias ll<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;ls -alF&#39;</span>
</span></span></code></pre></div><p>That&rsquo;s it. I could add more, but I&rsquo;ve found that too many aliases make you forget the actual commands, which hurts you when working on systems that don&rsquo;t have your config.</p><h2 id=understanding-whats-happening>Understanding What&rsquo;s Happening</h2><p>Let me explain the key components of my setup:</p><h3 id=the-compinit-function>The <code>compinit</code> Function</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>autoload -Uz compinit
</span></span><span style=display:flex><span>compinit
</span></span></code></pre></div><p>This initializes zsh&rsquo;s completion system. The <code>autoload -Uz</code> tells zsh to load the function when needed (lazy loading), and the <code>U</code> flag ensures it&rsquo;s loaded even if there are aliases for the same name.</p><h3 id=script-sourcing-with-error-handling>Script Sourcing with Error Handling</h3><p>Instead of blindly sourcing files that might not exist, I check first:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>local scripts_to_source<span style=color:#f92672>=(</span>
</span></span><span style=display:flex><span>    ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh
</span></span><span style=display:flex><span>    ~/.zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
</span></span><span style=display:flex><span>    <span style=color:#75715e># ... more scripts</span>
</span></span><span style=display:flex><span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> script_file in <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>scripts_to_source[@]<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -r <span style=color:#e6db74>&#34;</span>$script_file<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    source <span style=color:#e6db74>&#34;</span>$script_file<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    print -P <span style=color:#e6db74>&#34;%F{yellow}Warning:%f Script not found: </span>$script_file<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span></code></pre></div><p>This approach:</p><ul><li>Prevents errors when scripts don&rsquo;t exist</li><li>Gives clear feedback about missing dependencies</li><li>Makes the config portable across different systems</li></ul><h2 id=making-the-switch>Making the Switch</h2><p>If you&rsquo;re currently using Oh My Zsh and want to try this approach:</p><ol><li><strong>Backup your current config</strong>: <code>cp ~/.zshrc ~/.zshrc.backup</code></li><li><strong>Start minimal</strong>: Begin with just the essentials (autosuggestions, syntax highlighting)</li><li><strong>Add incrementally</strong>: Only add features as you realize you need them</li><li><strong>Understand each piece</strong>: Don&rsquo;t copy-paste without understanding what each line does</li></ol><p>The goal isn&rsquo;t to recreate Oh My Zsh – it&rsquo;s to build exactly what you need and understand every piece of it.</p><h2 id=conclusion>Conclusion</h2><p>Oh My Zsh is a great project that has introduced countless developers to the power of zsh. But once you understand what you actually need from your shell, you might find that a custom configuration serves you better.</p><p>My lightweight setup gives me everything I need: smart completions, helpful suggestions, a beautiful prompt, and fast performance. Most importantly, I understand every line of my configuration and can modify it without fear of breaking some complex framework.</p><p>Sometimes the best tool is the one you build yourself – even if it&rsquo;s simpler than the popular alternative.</p><hr><p><em>Here you can find my complete zsh configuration: <a href=../../content-assets/no-you-dont-need-ohmyzsh/zshrc>zshrc</a></em></p></article></main><div id=bottom-nav class="text-center center-block"><a href=https://segflow.github.io/ class="btn btn-default"><i class="fa fa-home"></i> Home</a></div><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//segflow-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div></div></div><script>(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)})(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-111743535-1","auto"),ga("send","pageview"),window.baseURL="https://segflow.github.io/"</script><script src=//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js></script><script src=//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.2/js/bootstrap.min.js></script><script src=//cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js></script><script src=//cdnjs.cloudflare.com/ajax/libs/topojson/1.6.9/topojson.min.js></script><script src=https://segflow.github.io//js/App.js></script></body></html>